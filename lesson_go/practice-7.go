package main

import (
	"fmt"
)

// 文字列について
func lessonString() {
	s := "Hello,"
	// 文字列は宣言通り、+で結合できる
	s += "world"
	fmt.Println(s)

	// 文字列はバイト列で構成されているため、スライスのように使うこともできる
	// ただし、文字列は不変（immutable）なので、要素の変更はできない

	// s[0]は文字列の最初のバイト（byte型、uint8のエイリアス）を取得
	// これは数値（ASCIIコード）を返す。'H'のASCIIコードは72
	fmt.Println("s[0]の数値:", s[0]) // 72と表示される

	// 単一スライスにしたらバイトを取得するだけなので、以下のようにしたら最初の一文字で行ける
	fmt.Println(s[0:1])

	// %cフォーマット指定子を使うと、数値を文字（Unicodeコードポイント）として表示できる
	fmt.Printf("s[0]の文字: %c\n", s[0]) // Hと表示される

	// s[0:5]は文字列のスライシング操作
	// インデックス0から4まで（5文字目まで）の部分文字列を取得
	// これは文字列型（string）を返すため、そのまま文字列として表示される
	fmt.Println("s[0:5]:", s[0:5]) // Helloと表示される（インデックス0,1,2,3,4の5文字）

	// 文字列の長さ（バイト数）を取得
	fmt.Println("文字列の長さ:", len(s))

	// しかしgoのstringはイミュータブルなので、書き換えることはできない
	// 以下のように特定の要素を書き換えることはできない。
	//s[0] = "h"

	// 書き換えるにはバイト列に変換してから書き換える。もちろん文字を超えた部分、バイト列の長さを超えようとするとpanicになる。
	b := []byte(s)
	b[0] = 'h'
	s = string(b) // 再代入する形でイミュータブルなstringを書き換えることができる。
	fmt.Println(s)

	// rune型にするとunicodeで扱える
	s2 := "Hello, 世界"
	r := []rune(s2)
	fmt.Println(r[0])
	r[0] = 'h'
	fmt.Println(string(r))

	content := `
バッククォート使うことで
複数行の文字列を扱える
	`
	fmt.Println(content)
}
